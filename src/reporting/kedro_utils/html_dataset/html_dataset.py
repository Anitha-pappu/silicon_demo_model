# Copyright (c) 2016 - present
# QuantumBlack Visual Analytics Ltd (a McKinsey company).
# All rights reserved.
#
# This software framework contains the confidential and proprietary information
# of QuantumBlack, its affiliates, and its licensors. Your use of these
# materials is governed by the terms of the Agreement between your organisation
# and QuantumBlack, and any unauthorised use is forbidden. Except as otherwise
# stated in the Agreement, this software framework is for your internal use
# only and may only be shared outside your organisation with the prior written
# permission of QuantumBlack.

import os
import typing as tp
from copy import deepcopy
from pathlib import PurePosixPath

import fsspec
import pandas as pd
from kedro.io.core import (
    AbstractVersionedDataset,
    DatasetError,
    Version,
    get_filepath_str,
    get_protocol_and_path,
)

from reporting.rendering.html.report_generation import generate_html_report


class HtmlReportDataset(AbstractVersionedDataset[pd.DataFrame, pd.DataFrame]):

    """``HtmlReportDataSet``  saves Report instances.
        The underlying functionality is supported by,
        and passes input arguments through to,
        generate_html_report method

    Example using Python API:
    >>> from kedro.io import DataCatalog
    >>> from reporting.kedro_utils import HtmlReportDataset
    >>>
    >>>
    >>> report_structure = {
    ...     "Section1": figure1,
    ...     "Section2": figure2,
    ... }
    >>>
    >>> html_report_dataset = HtmlReportDataSet(filepath="path/to/report.html")
    >>> catalog = DataCatalog(data_sets={'report': report})
    >>> catalog.save("report", report_structure)
     """

    DEFAULT_LOAD_ARGS = {}
    DEFAULT_SAVE_ARGS = {}

    def __init__(
        self,
        filepath: str,
        load_args: tp.Optional[tp.Dict[str, tp.Any]] = None,
        save_args: tp.Optional[tp.Dict[str, tp.Any]] = None,
        version: tp.Optional[Version] = None,
        credentials: tp.Optional[tp.Dict[str, tp.Any]] = None,
        fs_args: tp.Optional[tp.Dict[str, tp.Any]] = None,
    ) -> None:
        """
        Creates a new instance of ``ReportDataSet`` which extends the
         AbstractVersionedDataset class from kedro.

        Args:
         filepath: Filepath in POSIX format to a html file prefixed with a protocol
             like ``s3://``. If prefix is not provided,
             ``file`` protocol (local filesystem) will be used.
             The prefix should be any protocol supported by ``fsspec``.
             Note: ``http(s)`` doesn't support versioning.
         load_args: Currently Not Implemented
         save_args: Specify additional arguments to be passed to generate_html_report
         version: If specified, should be an instance of
             ``kedro.io.core.Version``. If its ``load`` attribute is
             ``None``, the latest version will be loaded. If its ``save``
             attribute is ``None``, save version will be autogenerated.
         credentials: Credentials required to get access to the underlying
                      filesystem. E.g. for ``GCSFileSystem`` it should look
                      like ``{"token": None}``
         fs_args: Extra arguments to pass into underlying filesystem class
                 constructor (e.g. ``{"project": "my-project"}`` for ``GCSFileSystem``)

        """

        _fs_args = deepcopy(fs_args) or {}  # noqa: WPS122
        _credentials = deepcopy(credentials) or {}  # noqa: WPS122

        protocol, path = get_protocol_and_path(filepath, version)
        if protocol == "file":
            _fs_args.setdefault("auto_mkdir", True)  # noqa: WPS121

        self._protocol = protocol
        self._storage_options = {**_credentials, **_fs_args}  # noqa: WPS121
        self._fs = fsspec.filesystem(self._protocol, **self._storage_options)

        super().__init__(
            filepath=PurePosixPath(path),
            version=version,
            exists_function=self._fs.exists,
            glob_function=self._fs.glob,
        )
        self._load_args = deepcopy(self.DEFAULT_LOAD_ARGS)
        if load_args is not None:
            self._load_args = load_args
        self._save_args = deepcopy(self.DEFAULT_SAVE_ARGS)
        if save_args is not None:
            self._save_args = save_args

    def _load(self) -> None:
        """
        Load method is not implemented for ``HtmlReportDataSet``
        """
        raise DatasetError(
            "Load functionality is not implemented for `HtmlReportDataSet` dataset",
        )

    def _save(self, data) -> None:
        """
        Call the ``generate_html_report`` function, which takes in the report
        dictionary, converts it to a html report and stores it at the specified path.
        """
        save_path = get_filepath_str(self._get_save_path(), self._protocol)
        try:
            generate_html_report(
                report_structure=data,
                render_path=save_path,
                **self._save_args,
            )
        # kedro AbstractVersionedDataset expects FileNotFoundError if a file with
        # the same name already exists.
        except FileExistsError as err:
            raise FileNotFoundError from err

    def _describe(self) -> tp.Dict[str, tp.Any]:
        """
        Return a dictionary containing values of important parameters of the dataset
        """
        return {
            "filepath": self._filepath,
            "load_args": self._load_args,
            "protocol": self._protocol,
            "save_args": self._save_args,
            "version": self._version,
        }

    def _release(self) -> None:
        """
        Call the ``release`` function of parent class and call the ``invalidate_cache``
        function of current class
        """
        super()._release()
        self._invalidate_cache()

    def _invalidate_cache(self) -> None:
        """Invalidate underlying filesystem caches."""
        filepath = get_filepath_str(self._filepath, self._protocol)
        self._fs.invalidate_cache(filepath)

    def _exists(self):
        """
        Check if the dataset exists in the specified filepath
        """
        return os.path.exists(self._filepath)
