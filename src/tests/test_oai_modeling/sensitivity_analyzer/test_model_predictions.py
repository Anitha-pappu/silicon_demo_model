# Copyright (c) 2016 - present
# QuantumBlack Visual Analytics Ltd (a McKinsey company).
# All rights reserved.
#
# This software framework contains the confidential and proprietary information
# of QuantumBlack, its affiliates, and its licensors. Your use of these
# materials is governed by the terms of the Agreement between your organisation
# and QuantumBlack, and any unauthorised use is forbidden. Except as otherwise
# stated in the Agreement, this software framework is for your internal use
# only and may only be shared outside your organisation with the prior written
# permission of QuantumBlack.


import typing as tp

import numpy as np
import pandas as pd
import pytest

from modeling import ModelBase, SklearnModel
from modeling.sensitivity_analyser.model_predictions import (
    ModelPrediction,
    make_model_predictions_for_features_to_plot,
)


class TestModelPredictions(object):
    """
    Test predictions generated by `make_model_predictions_for_features_to_plot`
    can be extracted from `ModelPrediction` and match the model predictions made with
    by explicit setting the dataset value.
    """
    @pytest.mark.parametrize(
        "condition_values,feature_values",
        [
            ([52], [17]),
            ([52, 57], [15, 20]),
            ([52, 57], [57, 52]),
            ([52, 55, 56, 57], [11, 12, 14, 16, 20]),
            ([52], [11, 12, 14, 16, 20]),
            ([52, 55, 56, 57], [11]),
        ],
    )
    def test_prediction_are_correct_for_single_feature(
        self,
        simple_data: pd.DataFrame,
        trained_sklearn_model: SklearnModel,
        condition_values: tp.List[float],
        feature_values: tp.List[float],
    ) -> None:
        condition_name = "% Iron Feed"
        feature_name = "% Silica Feed"
        manageable_conditions = {
            condition_name: condition_values,
        }
        features_to_plot = {
            feature_name: feature_values,
        }
        model_predictions = make_model_predictions_for_features_to_plot(
            features_to_plot=features_to_plot,
            features_to_manipulate=manageable_conditions,
            model=trained_sklearn_model,
            static_feature_values=simple_data.iloc[-1].to_dict(),
        )
        _assert_model_predictions_are_correct(
            condition_name,
            condition_values,
            feature_name,
            feature_values,
            simple_data,
            trained_sklearn_model,
            model_predictions,
        )
        _assert_model_features_are_correct(
            condition_values,
            feature_name,
            feature_values,
            model_predictions,
        )

    @pytest.mark.parametrize(
        "first_condition_values,second_condition_values,feature_values",
        [
            ([52], [65], [17]),
            ([52], [65], [15, 20]),
            ([52], [65, 66, 67], [17]),
            ([52, 57], [65], [17]),
            ([52, 57], [65, 66, 67], [17]),
            ([52, 57], [65], [15, 20]),
            ([52], [65, 66, 67], [15, 20]),
            ([52, 57], [65, 66, 67], [15, 20]),
        ],
    )
    def test_predictions_are_correct_for_multiple_features_to_manipulate(
        self,
        simple_data: pd.DataFrame,
        trained_sklearn_model: SklearnModel,
        first_condition_values: tp.List[float],
        second_condition_values: tp.List[float],
        feature_values: tp.List[float],
    ) -> None:
        first_condition_name = "% Iron Feed"
        second_condition_name = "% Iron Concentrate"
        feature_name = "% Silica Feed"
        manageable_conditions = {
            first_condition_name: first_condition_values,
            second_condition_name: second_condition_values,
        }
        features_to_plot = {
            feature_name: feature_values,
        }
        model_predictions = make_model_predictions_for_features_to_plot(
            features_to_plot=features_to_plot,
            features_to_manipulate=manageable_conditions,
            model=trained_sklearn_model,
            static_feature_values=simple_data.iloc[-1].to_dict(),
        )
        first_condition = enumerate(manageable_conditions[first_condition_name])
        second_condition = enumerate(manageable_conditions[second_condition_name])
        feature_to_plot = enumerate(features_to_plot[feature_name])
        for first_condition_index, first_condition_value in first_condition:
            for second_condition_index, second_condition_value in second_condition:
                np.testing.assert_allclose(
                    model_predictions[feature_name].get_model_feature_values_at_index(
                        (first_condition_index, second_condition_index),
                    ),
                    sorted(feature_values),
                )
                for feature_index, feature_value in feature_to_plot:
                    data = simple_data.iloc[[-1]].copy()
                    data[feature_name] = feature_value
                    data[first_condition_name] = first_condition_value
                    data[second_condition_name] = second_condition_value
                    reference_prediction = trained_sklearn_model.predict(data)
                    prepared_prediction = (
                        model_predictions[feature_name].get_model_predictions_at_index(
                            (first_condition_index, second_condition_index),
                        )
                    )
                    np.testing.assert_allclose(
                        prepared_prediction[feature_index],
                        reference_prediction,
                    )

    @pytest.mark.parametrize(
        "condition_values,first_feature_values,second_feature_values",
        [
            ([52], [65], [17]),
            ([52], [65], [15, 20]),
            ([52], [65, 66, 67], [17]),
            ([52, 57], [65], [17]),
            ([52, 57], [65, 66, 67], [17]),
            ([52, 57], [65], [15, 20]),
            ([52], [65, 66, 67], [15, 20]),
            ([52, 57], [65, 66, 67], [15, 20]),
        ],
    )
    def test_predictions_are_correct_for_multiple_features_to_plot(
        self,
        simple_data: pd.DataFrame,
        trained_sklearn_model: SklearnModel,
        condition_values: tp.List[float],
        first_feature_values: tp.List[float],
        second_feature_values: tp.List[float],
    ):
        condition_name = "% Iron Feed"
        first_feature_name = "% Iron Concentrate"
        second_feature_name = "% Silica Feed"
        manageable_conditions = {
            condition_name: condition_values,
        }
        features_to_plot = {
            first_feature_name: first_feature_values,
            second_feature_name: second_feature_values,
        }
        model_predictions = make_model_predictions_for_features_to_plot(
            features_to_plot=features_to_plot,
            features_to_manipulate=manageable_conditions,
            model=trained_sklearn_model,
            static_feature_values=simple_data.iloc[-1].to_dict(),
        )
        _assert_model_predictions_are_correct(
            condition_name,
            condition_values,
            first_feature_name,
            first_feature_values,
            simple_data,
            trained_sklearn_model,
            model_predictions,
        )
        _assert_model_predictions_are_correct(
            condition_name,
            condition_values,
            second_feature_name,
            second_feature_values,
            simple_data,
            trained_sklearn_model,
            model_predictions,
        )
        _assert_model_features_are_correct(
            condition_values,
            first_feature_name,
            first_feature_values,
            model_predictions,
        )
        _assert_model_features_are_correct(
            condition_values,
            second_feature_name,
            second_feature_values,
            model_predictions,
        )


def _assert_model_predictions_are_correct(
    condition_name: str,
    condition_values: tp.Iterable[float],
    feature_name: str,
    feature_values: tp.Iterable[float],
    data: pd.DataFrame,
    model: ModelBase,
    model_prediction: tp.Dict[str, ModelPrediction],
) -> None:
    for condition_index, condition_value in enumerate(condition_values):
        for feature_index, feature_value in enumerate(feature_values):
            data = data.iloc[[-1]].copy()
            data[feature_name] = feature_value
            data[condition_name] = condition_value
            reference_prediction = model.predict(data)
            prepared_prediction = (
                model_prediction[feature_name].get_model_predictions_at_index(
                    (condition_index,),
                )
            )
            np.testing.assert_allclose(
                prepared_prediction[feature_index],
                reference_prediction,
            )


def _assert_model_features_are_correct(
    condition_values: tp.Iterable[float],
    feature_name: str,
    feature_values: tp.Iterable[float],
    model_prediction: tp.Dict[str, ModelPrediction],
) -> None:
    for condition_index, _ in enumerate(condition_values):
        prepared_model_features = (
            model_prediction[feature_name].get_model_feature_values_at_index(
                (condition_index,),
            )
        )
        np.testing.assert_allclose(prepared_model_features, feature_values)
